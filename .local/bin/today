#!/home/rafa/.config/dotfiles/.local/bin/.venv/bin/python3

import os
import sys
from datetime import datetime
from argparse import ArgumentParser

try:
    from timefhuman import timefhuman
except ImportError:
    raise ImportError("timefhuman is required. Install with: pip install timefhuman")


def get_date_files(date_input, create=False):
    """
    Get the path to the appropriate vimwiki diary file(s) based on natural language input.
    
    Args:
        date_input: Natural language date string (e.g., "next week", "tomorrow")
        create: If True, create the file if it doesn't exist. If False, only return existing files.
    
    Returns:
        List of file paths (usually just one, but could be multiple for date ranges)
    """
    home = os.path.expanduser('~')
    base_dir = f'{home}/vimwiki/diary'
    
    print(f"Debug: Input date string = '{date_input}'", file=sys.stderr)
    print(f"Debug: Current datetime = {datetime.now()}", file=sys.stderr)
    
    # Parse the natural language date input
    try:
        results = timefhuman(date_input, now=datetime.now())
        print(f"Debug: timefhuman results = {results}", file=sys.stderr)
        print(f"Debug: results type = {type(results)}", file=sys.stderr)
        
        if not results:
            raise ValueError(f"Could not parse date: {date_input}")
            
        result = results[0] if isinstance(results, list) else results
        
        # Handle various return types
        if isinstance(result, tuple):
            # Date range, convert to list
            print(f"Debug: tuple result detected: {result}", file=sys.stderr)
            dates = list(result)
        elif isinstance(result, list):
            # Alternatives, take the first
            print(f"Debug: list result detected: {result}", file=sys.stderr)
            first = result[0]
            if isinstance(first, tuple):
                # Date range inside alternatives
                dates = list(first)
                print(f"Debug: list/tuple detected: {dates}", file=sys.stderr)
            else:
                dates = [first]
        else:
            # Single datetime
            print(f"Debug: single datetime detected: {result}", file=sys.stderr)
            dates = [result]
            
    except Exception as e:
        print(f"Error parsing date: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)
    
    print(f"Debug: final dates list = {dates}", file=sys.stderr)
    
    # Convert dates to file paths
    file_paths = []
    for date in dates:
        date_str = date.strftime('%Y-%m-%d')
        file_path = f'{base_dir}/{date_str}.md'
        print(f"Debug: checking file path = {file_path}", file=sys.stderr)
        
        # Create file if requested, otherwise only return existing files
        if create:
            os.makedirs(base_dir, exist_ok=True)
            if not os.path.exists(file_path):
                with open(file_path, 'w') as f:
                    pass  # Create empty file
        
        if os.path.exists(file_path):
            file_paths.append(file_path)
            print(f"Debug: added file path = {file_path}", file=sys.stderr)
    
    # If no files exist and we're not creating, return empty list
    return file_paths


def main():
    # Simple argument parsing - any unrecognized argument is considered part of the date
    args = sys.argv[1:]
    
    # Check for --create flag
    create = False
    if '--create' in args:
        create = True
        args.remove('--create')
    
    # Join remaining arguments as date input
    date_input = ' '.join(args) if args else 'today'
    
    print(f"Debug: final input = '{date_input}'", file=sys.stderr)
    
    files = get_date_files(date_input, create=create)
    
    # Print all matched file paths
    for file_path in files:
        print(file_path)


if __name__ == '__main__':
    main()
