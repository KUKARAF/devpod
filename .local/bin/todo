#!/home/rafa/.config/dotfiles/.venv/bin/python
"""
CLI tool for managing todos from markdown files.

Usage:
    today | todo get                          # Show todos due today or overdue
    today | todo edit                         # Open files in default editor
    week | todo show                          # Print all todos from week
    today | todo done                         # Interactive (fzf) mark done
    todo add "task text #tag @location"       # Add new todo (uses today's file by default)
    todo add "task due:tomorrow #tag"         # Add todo with custom due date
    todo done path/to/file.md 42              # Directly mark line 42 in file as done
"""

import sys
import subprocess
import os
import re
from datetime import datetime
from pathlib import Path
from todo import Todo

try:
    from timefhuman import timefhuman
except ImportError:
    raise ImportError("timefhuman is required. Install with: pip install timefhuman")


# Default directory for storing todos
DEFAULT_TODO_DIR = Path.home() / "vimwiki" / "diary"


def read_files_from_stdin() -> list[str]:
    """Read file paths from stdin"""
    files = []
    for line in sys.stdin:
        line = line.strip()
        if line and line.endswith('.md'):
            files.append(line)
    return files


def parse_args() -> tuple[str, list[str]]:
    """Parse command line arguments"""
    if len(sys.argv) < 2:
        print("Usage: <files> | todo <command>", file=sys.stderr)
        print("       todo add <text>", file=sys.stderr)
        print("       todo done [<file_path> <line_number>]", file=sys.stderr)
        print("Commands: get, show, edit, add, done", file=sys.stderr)
        sys.exit(1)
    
    command = sys.argv[1].lower()
    
    # 'add' and direct 'done' don't require stdin
    if command in ('add', 'done'):
        if command == 'add' and len(sys.argv) < 3:
            print("Usage: todo add <text>", file=sys.stderr)
            sys.exit(1)
        # done with two extra args = direct mode; otherwise it's interactive and needs stdin
        if command == 'done' and len(sys.argv) >= 4:
            return command, []  # direct mode
        return command, []
    
    files = read_files_from_stdin()
    
    if not files:
        print("Error: No files provided via stdin", file=sys.stderr)
        sys.exit(1)
    
    return command, files


def print_todo(todo_id: int, item: dict) -> None:
    """Print a single todo item"""
    text = item['text'].strip()
    # Remove checkbox for cleaner display
    text = text.replace('- [ ]', '').replace('* [ ]', '').strip()
    
    due_date_str = ""
    if item['due_date']:
        due_date_str = f" ðŸ“… {item['due_date'].strftime('%Y-%m-%d %H:%M')}"
    
    tags_str = ""
    if item['tags']:
        tags_str = f" {' '.join(f'#{tag}' for tag in item['tags'])}"
    
    locations_str = ""
    if item['locations']:
        locations_str = f" {' '.join(f'@{loc}' for loc in item['locations'])}"
    
    file_str = f"  ({Path(item['file']).name}:{item['line_number']})"
    
    print(f"{text}{due_date_str}{tags_str}{locations_str}{file_str}")


def cmd_show(files: list[str]) -> None:
    """Show all todos from given files"""
    todo = Todo(files)
    all_todos = todo.get_all()
    
    if not all_todos:
        print("No todos found")
        return
    
    # Group by file for organization
    todos_by_file = {}
    for todo_id, item in all_todos.items():
        file_path = item['file']
        if file_path not in todos_by_file:
            todos_by_file[file_path] = []
        todos_by_file[file_path].append((todo_id, item))
    
    for file_path in sorted(todos_by_file.keys()):
        print(f"\nðŸ“„ {Path(file_path).name}")
        print("â”€" * 60)
        for todo_id, item in todos_by_file[file_path]:
            print_todo(todo_id, item)


def cmd_get(files: list[str]) -> None:
    """Show todos due today/overdue, or Eisenhower quadrant if none due"""
    todo = Todo(files)
    all_todos = todo.get_all()
    
    if not all_todos:
        print("No todos found")
        return
    
    today = datetime.now().date()
    
    # Find todos due today or overdue
    due_today_or_overdue = {}
    for todo_id, item in all_todos.items():
        if item['due_date']:
            due_date = item['due_date'].date()
            if due_date <= today:
                due_today_or_overdue[todo_id] = item
    
    if due_today_or_overdue:
        print("ðŸ“Œ Due Today or Overdue:")
        print("â”€" * 60)
        for todo_id, item in due_today_or_overdue.items():
            print_todo(todo_id, item)
    else:
        # Fall back to Eisenhower matrix - show #important + #urgent
        important_urgent = {}
        for todo_id, item in all_todos.items():
            if 'important' in item['tags'] and 'urgent' in item['tags']:
                important_urgent[todo_id] = item
        
        if important_urgent:
            print("âš¡ Important & Urgent:")
            print("â”€" * 60)
            for todo_id, item in important_urgent.items():
                print_todo(todo_id, item)
        else:
            print("No urgent todos found")


def cmd_edit(files: list[str]) -> None:
    """Open all files in default editor"""
    editor = os.environ.get('EDITOR', 'vim')

    unique_files = []
    seen = set()
    for f in files:
        if f not in seen:
            unique_files.append(f)
            seen.add(f)

    try:
        # Redirect stdin to terminal so editor works properly with pipes
        with open('/dev/tty') as tty:
            subprocess.run([editor] + unique_files, stdin=tty, check=True)
    except FileNotFoundError:
        print(f"Error: Editor '{editor}' not found", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("\nEdit cancelled")

def cmd_add(task_text: str) -> None:
    """Add a new todo item"""
    
    # Extract due date if present
    due_match = re.search(r'due:(\S+)', task_text)
    due_date = None
    target_file = None
    
    if due_match:
        due_str = due_match.group(1)
        # Parse with timefhuman using today as context
        try:
            results = timefhuman(due_str, now=datetime.now())
            if results:
                result = results[0] if isinstance(results, list) else results
                
                # Handle various return types
                if isinstance(result, tuple):
                    due_date = result[0]
                elif isinstance(result, list):
                    first = result[0]
                    due_date = first[0] if isinstance(first, tuple) else first
                else:
                    due_date = result
                
                # Debug output
                print(f"Debug: Parsed due date: {due_date}", file=sys.stderr)
        except Exception as e:
            print(f"Error parsing due date: {e}", file=sys.stderr)
            sys.exit(1)
    
    # Determine target file
    if due_date:
        target_file = DEFAULT_TODO_DIR / f"{due_date.strftime('%Y-%m-%d')}.md"
    else:
        target_file = DEFAULT_TODO_DIR / f"{datetime.now().strftime('%Y-%m-%d')}.md"
    
    # Create directory if needed
    target_file.parent.mkdir(parents=True, exist_ok=True)
    
    # Create file if it doesn't exist
    if not target_file.exists():
        target_file.touch()
    
    # Remove the due:date from task text since the date is stored in the filename
    cleaned_text = re.sub(r'due:\S+\s*', '', task_text).strip()
    
    # Append todo to file
    with open(target_file, 'a', encoding='utf-8') as f:
        f.write(f"- [ ] {cleaned_text}\n")
    
    print(f"âœ… Added to {target_file.name}")
    print(f"   - [ ] {cleaned_text}")


def cmd_done_interactive(files: list[str]) -> None:
    """Interactive (fzf) todo completion."""
    todo = Todo(files)
    all_todos = todo.get_all()
    if not all_todos:
        print("No todos found")
        return

    # Build idâ†’todo map and display list
    id_map = {}
    display_lines = []
    for tid, item in all_todos.items():
        id_map[tid] = item
        # Minimal display: first 60 chars of text, plus id for internal use
        text = item["text"].strip().replace("- [ ]", "").replace("* [ ]", "").strip()
        display = f"{tid:>4} {text[:60]}"
        display_lines.append(display)

    # Call fzf
    fzf_input = "\n".join(display_lines)
    try:
        result = subprocess.run(
            ["fzf", "--multi", "--preview", "echo {}", "--preview-window=up:1"],
            input=fzf_input,
            text=True,
            capture_output=True,
            check=True,
        )
    except subprocess.CalledProcessError:
        # fzf returned non-zero (user cancelled)
        return

    # Parse selected lines
    selected_lines = result.stdout.strip().splitlines()
    if not selected_lines or selected_lines == [""]:
        return

    # Mark each selected todo done
    for line in selected_lines:
        # line format: "  42 Do the thing..."
        idx_str = line.strip().split()[0]
        try:
            todo_id = int(idx_str)
            if todo_id in id_map:
                todo.mark_todo_done(todo_id)
        except ValueError:
            continue


def cmd_done_direct(file_path: str, line_number: str) -> None:
    """Mark a specific todo line as done"""
    try:
        line = int(line_number)
        Todo.mark_done(file_path, line)
        print(f"âœ… Marked line {line_number} in {Path(file_path).name} as done")
    except Exception as e:
        print(f"Error marking done: {e}", file=sys.stderr)
        sys.exit(1)


def main():
    command, files = parse_args()
    
    if command == 'get':
        cmd_get(files)
    elif command == 'show':
        cmd_show(files)
    elif command == 'edit':
        cmd_edit(files)
    elif command == 'add':
        task_text = ' '.join(sys.argv[2:])
        cmd_add(task_text)
    elif command == 'done':
        if len(sys.argv) >= 4:  # direct mode
            file_path = sys.argv[2]
            line_number = sys.argv[3]
            cmd_done_direct(file_path, line_number)
        else:  # interactive mode
            files_interactive = read_files_from_stdin() if not files else files
            if not files_interactive:
                print("Error: No files provided via stdin for interactive done", file=sys.stderr)
                sys.exit(1)
            cmd_done_interactive(files_interactive)
    else:
        print(f"Unknown command: {command}", file=sys.stderr)
        print("Commands: get, show, edit, add, done", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
